##ApproachAfter reading the initial requirements I knew I first needed to brush up on my roman numeral knowledge and logic before anything.A quick look at various resources on the internet gave me the following points I needed to be aware of in my method logic:- Subtractive notation:-- If one or more letters are placed after another letter of greater value, add that amount.-- If a letter is placed before another letter of greater value, subtract that amount.- The same roman numeral can only be repeated three times.From here I could start thinking about how this logic would look using standard programming functions:- An object containing key-value pairs with the key being the Roman numeral value and the value being the associated numeric value.- Method that takes a numeric parameter.- Loop to go over this numeric value and compare it to the roman numerals object with some form of subtractive notation in mind. The final implementation of this is discussed below.- Use standard greater than or less than operators for the 1 to 3999 validation.Once I had some of the basic logic noted down I could make a valid decision on what was the best language to use to implement this.Using the following points, I decided I wanted to use ReactJS:- Instead of giving you a compiled file in a zip, I thought it would be nice to host it on GitHub where you can check out all of the code easily and I can run a demo online using GitHub Pages.- I could easily achieve some part of the validation via Front-End HTML5 validators on the input field: min=0, max=3999, type="number" **CAVEAT** HTML5 validation only works in modern browsers and is still not great in IE.- I enjoy using the test tools that react supports (Jest/Enzyme).- React is the strongest language in my programming tool-belt.- I feel ES6 functions read nicely when implemented correctly.- Using create-react-app I knew I could get up and running fast without writing any boilerplate code.##Implementation - Created the App using create-react-app.- Separated out the logic for the converter into its own component RomanNumeralConverter as this gives me various bonuses:-- I can reuse this component whenever I want.-- Makes it easier to read.-- I can use PropTypes.-- Although it doesn't really make it easier to test as its such a small component it does allow me to split my tests out into their own separate test components for easier management.- Setup the input number field in the main App component to update the state when a value is inserted into the input field and then pass this value as a propinto my RomanNumeralConverter component.- Setup the PropTypes to check for a numeric prop.- Setup my romanNumeralLookUp key-value pair object.- Created the handleConversion function that took the numberInserted passed in from the App component:-- Checked the validation of the numberInserted inserted with an if statement:--- If it didn't pass, a validation message is returned.--- If it did pass, it then loops over the romanNumeralLookUp object with the numberInserted inserted checking if numberInserted is greater than or equal toeach value in the romanNumeralLookUp object. -- If true it adds the key for that value to the convertedRomanNumeral variable.-- It then takes away the value of the key that was added to the convertedRomanNumeral variable from the numberInserted parameter. -- This cycle is iterated over in the while loop until the numberInserted reaches 0 and it falls out of the for loop as 0 is not in the romanNumeralLookUp object.-- At this point, the function then returns the convertedRomanNumeral variable.###TestingTesting wise I used a mixture of unit tests and a snapshot test. Snapshot tests may have been a little overkill but it's quite nice to have. As for unit tests, I utilised Enzyme to shallow render my components.Using this shallow render, I could easily get a handle on my roman numeral converter method and pass it whatever number I wanted and assert the roman numeral I wanted to see.I didn't want to go overboard on this so I tested the numbers that I felt needed testing based on subtractive notation.I checked that my validation was working by passing outer boundary numbers to the method and asserted the validation message was displayed.As for the input field in the main App component, I simply checked the input field had the correct properties when rendered. So min, max and number type.I also checked that when a valid number is inserted into the input box it updates the numberInserted state via the onChange method.I would have liked to have used the jest assertion .toHaveBeenCalled but for some bizarre reason, I couldn't get that assertion working for the onChange method.Testing was even further enforced by using Reacts PropTypes checking that only a numeric value was passed to this function.##Things I would have done differently:- Used a different language I wasn't as comfortable with.- Used TDD.- Handle the validation in a separate method to simplify the handleConverstion method and to reduce calls to the method when the value is out of the numeric boundaries. - For some reason and I am not sure why yet I couldn't test trying to put alpha characters into the input box, maybe I need to do a mount? I am unsure, to be honest.- I think I could probably think of a cool way to test the .handleConverstion method but I have yet to come up with something cool.- Overall I feel the validation could be done a bit better, maybe having a method to strip out any unneeded characters when the user inserts them into the input field. As right now you can go a bit crazy with inserts on the input field and you get weird results.